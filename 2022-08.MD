## 2022-08-03
### 论文复现工作
1. 安装ida，笔记本。
2. 恢复重装系统前的环境
3. 跑一遍代码，获取正确的result.json
   1. 向师姐要了样本代码（以后重装系统不能弄丢工作文件:(
   2. 出现了bug，‘gbk‘ codec can‘t decode byte 0xbf in position ，通过修改ida软件的E:\tools\IDApro\python\3\ida_idaapi.py 文件的602行 改with open(script) as fin:为with open(script,encoding='UTF-8') as fin:
   3. 目前还是会报错误 暂时不知怎么修改，但是不影响跑出结果，先不修改File "E:\tools\IDApro\python38\lib\site-packages\keystone\keystone.py", line 75, in <module>
    raise ImportError("ERROR: fail to load the dynamic library.")
ImportError: ERROR: fail to load the dynamic library.
### 吉他练习
1. 音阶练习p9-p11

### 运动
1. 哑铃15min

## 2022-08-04
### 论文复现工作
1. 没做。。。

### mcafx项目
1. 熟悉环境 明天去TBD部署项目，需要提前熟悉系统环境。centos8
2. centos安装
   1. centos8虚拟机安装。目前有两个版本，一个是root，一个是dvd。root比较小不到1g，是轻量级版本，dvd比较大10g。
   2. 我安装的是root版本，dvd还在下载中。
3. centos使用
   1. 用户名密码：用户名是root，密码是之前安装的时候设置的
   2. 一开始没有python命令
   3. systemctl disable firewalld 禁止开机启用防火墙
   4. systemctl stop firewalld 停止防火墙服务
   5. 虚拟机网段设置
      1. 编辑-虚拟网段编辑器
      2. 更改设置
      3. vmnet8，子网ip修改
      4. DHCP起始地址结束地址均修改成上一条的ip
      5. 确定应用
   6. ip addr 查看网络信息
   7. xshell,xftp下载安装
   8. 使用xshell操作centos
   9. 修改静态ip
   10. 安装python过程中遇到的错误：
       1.  问题解决：Failed to download metadata for repo ‘appstream‘: Cannot prepare internal mirrorlist:...
       2.  https://blog.51cto.com/u_15197573/5267140
   11. 按照博客安装python3.8，安装失败。用dvd镜像试一试。。。
   12. 遇到了相同的问题，但是成功了
       1.  mv /usr/bin/python /usr/bin/python.bak 这一步不用做
       2.  ln -s /usr/local/python3/bin/python3 /usr/bin/python这步做
       3.  ln -s /usr/local/python3/bin/pip3 /usr/bin/pip这步做
   13. 使用xftp传送项目相关文件到虚拟机
   14. 使用pip安装环境
   15. 遇到小坑，没有关闭新安装的centosdvd的防火墙，导致能ping通，能传输文件，但是浏览器不能访问
   16. 3，4条指令禁用防火墙
   17. python manage.py runserver 0.0.0.0:8000

## 2022-08-05
### 项目部署
1. 早上9.30过去晚上9.30才回宿舍
2. 部署了一天，在局域网能够调通，并且访问项目，但是没有连外网
   
## 2022-08-06

### 论文复现工作
1. 在实验室电脑配置环境
2. 调通代码
3. 得到正确的result.json文件
4. simhash代码完成，并且集成到浮现工作中--未完成

## 本周计划2022-08-08（周一）
1. 论文分享工作完成(周六必须完成)
2. 论文复现工作
   1. 重新阅读论文，梳理思路
   2. simhash代码复现
   3. 再实现新的一个模块的代码
3. java学习
   1. 看到p199

## 2022-08-09（周二）

### 前两天荒废了
### 调研报告
1. 完成第二部分内容

### 论文分享
1. 确定要分享的论文

## 2022-08-10
### 论文分享
1. 翻译完论文

## 2022-08-11（周四）
### 论文分享
1. 理清论文的思路
2. 制作ppt
3. 制作文字稿

## 2022-08-12
### 论文分享
1. 阅读相关论文（10篇）
2. 丰富ppt
3. 更新文字稿

## 2022-08-13
### 论文分享
1. 检查论文ppt。重新梳理思路。核对文字稿

## 2022-08-16 + 2022-08-17
### mcafx项目
#### 可视化框架echarts学习
使用echarts的关系图来完成需求
##### echarts关系图学习
1. div定义html的承载echarts的容器
   1. ```html
        <div id="main" style="width: 600px;height:400px;"></div>
      ```
   2. ```html
        <div id="main"></div>
        <script type="text/javascript">
        var myChart = echarts.init(document.getElementById('main'), null, {
            width: 600,
            height: 400
        });
        </script>       
      ```
2. 可以改变主题
   1. ```JS 
        var chart = echarts.init(dom, 'dark');
      ```
   2. series-graph查手册的时候查这个关键词，这就是关系图
      1. series
         1. type: 'graph'
         2. layout: 'force', //采用力引导布局
         3. roam: true,//鼠标缩放
         4. force: {
               repulsion: 90, //节点之间的斥力因子。支持设置成数组表达斥力的范围，此时不同大小的值会线性映射到不同的斥力。值越大则斥力越大
               gravity: 0.58 //节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。
               edgeLength: 80 //支持设置成数组表达边长的范围，此时不同大小的值会线性映射到不同的长度。值越小则长度越长。

            }
         5. symbol: "circle" // 节点标记的图形。可以通过 'path://' 将图标设置为任意的矢量路径。这种方式相比于使用图片的方式，不用担心因为缩放而产生锯齿或模糊，而且可以设置为任意颜色。路径图形会自适应调整为合适的大小。路径的格式参见 SVG PathData。可以从 Adobe Illustrator 等工具编辑导出。
         6. symbolSize: 17//节点标记的大小，可以设置成诸如 10 这样单一的数字，也可以用数组分开表示宽和高，例如 [20, 10] 表示标记宽为20，高为10。
         7. itemStyle: {//图形样式，默认的其实可以用
               color: null,
               borderColor: "rgba(224, 106, 106, 1)",
               borderWidth: 1,
               borderType: "dotted"
            }
         8. lineStyle: {//边的样式，默认的其实可以用
               width: 1,
               join: "miter"
            }
         9. label: {//节点标签
               show: true,
               position: "left",
               distance: 10,
               rotate: 6,
               color: "rgba(180, 137, 137, 1)",
               fontStyle: "oblique",
               fontWeight: "lighter",
               fontFamily: "Arial",
               fontSize: 13,
               align: "center",
               borderType: "solid",
               borderWidth: 0.5,
               borderRadius: [6, 6, 6, 6],
               shadowColor: "rgba(230, 207, 207, 1)",
               backgroundColor: "rgba(224, 213, 213, 1)",
               borderColor: "rgba(31, 5, 5, 1)"
            }
         10. edgeLabel:{}\\边标签
         11. emphasis\\ 高亮相关设置
         12. data 关系节点的数据列表
             1.  name 节点的name不能重复
             2.  等等
             3.  data.symble.可以设定节点的图形，可以上传图片
         13. links 节点之间的关系数据
             1. value边的数值，可以在力引导布局中用于映射到边的长度
             2. source
             3. target
3. 图例legend
   1. 交互，点击控制显示或隐藏对应的数据列
4. 事件与行为
   1. 鼠标事件的处理，官网有例子点击柱状图后打开相应的百度搜索页面的示例。

         




#### 数据准备
制作用于可视化的虚构数据。
1. 类别

## 2022-08-19 
### 框架可视化当前工作总结
![](https://tallestdaisy.oss-cn-beijing.aliyuncs.com/img/20220819142136.png)

#### 图例legend
1. 展示了节点的种类，并且点击图例可以隐藏或者显示此类节点.图例的形状目前无法改成节点的形状（echarts不支持），只能通过图例的name来识别。

#### 节点
1. 每个节点的形状都代表它的种类。
2. 节点的左侧显示了它的名字。
##### 鼠标悬浮节点上
![](https://tallestdaisy.oss-cn-beijing.aliyuncs.com/img/20220819145523.png)
1. 节点左侧的名字显示成高亮信息，这里可以显示一些与名字不同的信息
2. 与节点相邻的节点和边都会突出，其余的节点和边都淡化。
3. 右上角显示节点的卡片信息，这里可以显示更多的信息

##### 点击节点
1. 单击一个节点可以弹出与这个节点相关的其他节点

#### 边
1. 边可以显示边的名字信息
##### 鼠标悬浮在边上
![](https://tallestdaisy.oss-cn-beijing.aliyuncs.com/img/20220819145858.png)
1. 边上的名字信息会变成另一种高亮信息。与边相连的两个节点会被突出，其他边的节点会被淡化。
2. 右上角会显示边的卡片信息，这里可以显示更多信息。

### java学习
#### 数据库学习
1. 多表查询
   1. ```sql
      select
         列名列表
      from
         表名列表
      ```
   2. 笛卡尔积，需要消除
   3. 内连接查询
      1. 隐式内连接：使用where条件消除无用数据
         1. select * from emp,departments where emp.dep_id = departments.id;
         2. select ename,joindate,name from emp,departments where emp.dep_id = departments.id;
         3. select t1.ename,t1.joindate,t2.name from emp t1,departments t2 where t1.dep_id = t2.id;-- 起别名，比较方便
      2. 显式内连接
         1. SELECT * FROM emp INNER JOIN departments ON emp.dep_id = departments.id;
         2. SELECT * FROM emp JOIN departments ON emp.dep_id = departments.id;
      3. 注意事项
         1. 从哪些表中查询数据
         2. 查询条件
   4. 外连接查询
      1. 左外连接
         1. select 字段列表 from 表1 left [outer] join 表2 on 条件；
         2. 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称。
         3. 如果用内连接SELECT t1.*,t2.`name` FROM emp t1, departments t2 where t1.dep_id = t2.id; 如果有员工的部门id为null，则这个查询就不会显示出这个员工的信息
         4. 这个时候就要用到左外连接
         5. SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN departments t2 ON t1.dep_id = t2.id;--这个时候就可以查询到没有部门id员工的信息了
         6. 左外连接，查询的是左表左右数据，以及其交集部分
      2. 右外连接
         1. select 字段列表 from 表1 right [outer] join 表2 on 条件；
   5. 子查询
      1. 概念：查询中嵌套查询，称嵌套的查询为子查询
      2. 例子
         1. 查询最高工资是多少（19999）
         2. 查询员工信息，并且工资等于19999的
         3. 以前，分为两步来查询
         4. 现在用一条sql来完成这个操作
         5. 第二次的9000就是第一次的结果
         6. SELECT * from emp WHERE emp.salary = (SELECT MAX(salary) FROM emp);
      3. 子查询不同情况
         1. 子查询的结果是单行单列的
            1. SELECT * from emp WHERE emp.salary = (SELECT MAX(salary) FROM emp);
            2. 子查询可以作为条件，使用运算符去判断
            3. SELECT * from emp WHERE emp.salary <= (SELECT AVG(salary) FROM emp);
            4. 查询金轮饭馆的所有员工信息
            5. SELECT * FROM emp WHERE emp.dep_id = (SELECT departments.id FROM departments WHERE `name` = "金轮饭馆")
         2. 子查询的结果是多行单列的
            1. 子查询可以作为条件，使用运算符in来判断
            2. 查询金轮饭馆和金轮大排档的所有员工信息
            3. SELECT * FROM emp WHERE emp.dep_id in (SELECT departments.id FROM departments WHERE `name` = "金轮饭馆" OR `name`="金轮大排档")
         3. 子查询的结果是多行多列的
            1. 子查询可以作为一张虚拟表来进行表的查询
            2. 查询员工的入职日期是1999-01-08之后的员工信息和部门信息
            3. 先查入职日期是1999-01-08之后的员工信息
            4. SELECT * FROM emp WHERE emp.joindate <= "1999-01-08";
            5. SELECT * FROM departments t1, (SELECT * FROM emp WHERE emp.joindate <= "1999-01-08") t2 WHERE t1.id = t2.dep_id;
            6. 普通的内连接也可以完成
            7. SELECT * FROM emp,departments WHERE emp.joindate <= "1999-01-08" and emp.dep_id = departments.id;
2. 事务
   1. 事务的基本介绍
      1. 事务操作，如果出现异常，就会回滚。要么成功，要么失败并回滚到开始。
      2. 三个操作
         1. 开启事务 start transaction
         2. 回滚 rollback
         3. 提交 commit 
      3. mysql数据库中，事务默认自动提交
         1. 一条dml增删改语句会自动提交事务，也就是持久化更新。
         2. 写了start transaction 就是手动提交
      4. 总结：事务提交的两种方式
         1. 自动提交 一条dml语句会自动提交事务
         2. 手动提交 使用start transaction 可以手动提交
      5. 查看事务的默认提交方式
         1. SELECT @@autocommit;
         2. 1 代表自动提交
         3. 0 代表手动提交
      6. 修改默认提交方式
         1. set @@autocommit = 0;
      7. oracle 数据库默认是手动提交事务
   2. 事务的四大特征
   3. 事务的隔离级别--了解就行


## 2022-08-22
### centos远程连接
#### 使用ssh可以命令行访问，不能图形界面

#### 安装centos图形界面虚拟机
1. 正常安装
2. 换源https://blog.csdn.net/weixin_44839439/article/details/124098769
3. Windows10远程桌面连接CentOS8 https://blog.csdn.net/weixin_44480968/article/details/124811330
4. 成功连接到了自己的虚拟机
5. ![](https://tallestdaisy.oss-cn-beijing.aliyuncs.com/img/20220822142418.png)
#### 用向日葵远程访问
被pass，云端连接不安全

#### 调研其他软件进行远程访问
##### tigervnc
1. 成功连接 https://serverspace.io/support/help/install-tigervnc-server-on-centos-8/    
### Java学习
#### 数据库学习
DCL 管理用户，授权
DBA  数据库管理员

1. 管理用户
   1. 添加用户
      1. 使用dcl语法来创建用户
      2. create user '用户名'@'主机名' identified by '密码';
      3. create user 'mingxuanshen'@'localhost' identified by '123456';
      4. create user 'xiaoqiezi'@'%' identified by '123456';
      5. 遇到Access denied for user 'mingxuanshen'@'localhost' (using password: YES)问题，登陆失败
      6. 这个问题没解决，先不管
   2. 删除用户
      1. drop user '用户名'@'主机名'
      2. drop user 'mingxuanshen'@'localhost'
   3. 修改用户密码
      1. update user set password = password('新密码') where user = "用户名";
      2. update user set password = PASSWORD("1234") where user = 'xiaoqiezi';
      3. 上面的语句没有运行成功，先不管了。
2. 权限管理 跳过了，先不看了
   1. 查询权限
   2. 授予权限 grant
   3. 撤销权限
#### JDBC学习
Java DataBase ConnectivityJava数据库连接
jdbc本质
mysql oracle DB2的语法各不相同
使用同一的一套java代码可以操作所有的关系型数据库
JDBC定义了操作所有关系型数据库的规则，定义了接口
各个数据库厂商，实现这些接口————数据库驱动
1. 快速入门
   1. 导入驱动jar包
      1. 复制jar包到项目的libs目录下
      2. add as library
   2. 注册驱动
   3. 获取数据库连接对象
      ```java
      String url = "jdbc:mysql://127.0.0.1:3306/db1?characterEncoding=UTF-8&serverTimezone=UTC";
      //下面这种也可以，只要是本机+默认端口号
      //String url = "jdbc:mysql:///db1?characterEncoding=UTF-8&serverTimezone=UTC";
      String username = "root";
      String password = "123456";
      Connection conn = DriverManager.getConnection(url,username,password);
        
      ```
   4. 定义sql
      ```java
      String sql = "update account set money = 20000 where id = 1";
      ```
   5. 获取执行sql语句的对象
      ```java
      Statement stmt = conn.createStatement();
      ```
   6. 执行sql，接受返回的结果
      ```java
      int count = stmt.executeUpdate(sql);
      ```
   7. 处理结果
      ```java
      System.out.println(count);
      ```
   8. 释放资源
      ```java
      stmt.close();
      conn.close();
      ```
2. 详解各个对象
   1. DriverManager
      1. 注册驱动
         1. DriverManager.registerDriver(new Driver());//静态方法
         2. Class.forName("com.mysql.cj.jdbc.Driver");
            ```java
            public class Driver extends NonRegisteringDriver implements java.sql.Driver {
               public Driver() throws SQLException {
               }

               static {
                  try {
                        DriverManager.registerDriver(new Driver());
                  } catch (SQLException var1) {
                        throw new RuntimeException("Can't register driver!");
                  }
               }
            }
            ```
         3. mysql5之后的驱动jar包可以省略注册驱动的步骤
      2. 获取数据库连接
         1. url指定连接的路径
            1. 语法，每一种数据库，都有差异
            2. mysql的语法
               ```java
               jdbc:mysql://ip地址：端口号/数据库名称
               jdbc:mysql://127.0.0.1:3306/db1
               jdbc:mysql:///db1
               ```
   2. Connection
      1. 获取执行sql的对象
      2. 管理事务
         1. 开启事务
            ```java
            conn.setAutoCommit(false);
            ```
         2. 提交事务
            ```java
            conn.commit();
            ```
         3. 回滚事务
            ```java
            conn.rollback();
            ```
   3. Statement
      1. 执行sql
         1. boolean execute(String sql)
         2. int executeUpdate(String sql)
         3. ResultSet executeQuery(String sql) 返回结果集对象
      2. 
   4. ResultSet
      1. 封装查询结果的对象
      2. next()
      3. 类似迭代器遍历
   5. PreparedStatement

3. 练习
```java
//释放资源的规范代码
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

public class JDBCDEMO3 {
    public static void main(String[] args) {
        String url = "jdbc:mysql://127.0.0.1:3306/db1?characterEncoding=UTF-8&serverTimezone=UTC";
        //下面这种也可以，只要是本机+默认端口号
        //String url = "jdbc:mysql:///db1?characterEncoding=UTF-8&serverTimezone=UTC";
        String username = "root";
        String password = "123456";
        Connection conn = null;
        Statement stmt = null;
        try {
            conn = DriverManager.getConnection(url, username, password);
            String sql = "insert into account(name,money) values('王五',3333.20)";
            stmt = conn.createStatement();
            int count = stmt.executeUpdate(sql);
            System.out.println(count);
            if(count > 0 ){
                System.out.println("插入成功");
            }else {
                System.out.println("插入失败");
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }finally {
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException e) {
                    throw new RuntimeException(e);
                }
            }
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }
}
```
4. 抽取JDBC工具类
   1. 获取链接
      
   3. 释放资源
   4. 


## 2022-08-23
### MCAFX项目
#### 远程桌面连接总结
1. 换源（可能服务器不需要换源,yum失败的时候要换源）
   1. 修改下面两个文件：
      1. cd /etc/yum.repos.d
      2. vi CentOS-Linux-BaseOS.repo
      3. vi CentOS-Linux-AppStream.repo
   2. CentOS-Linux-BaseOS.repo的内容修改为：
      ```
      [baseos]
      name=CentOS Linux $releasever - BaseOS
      #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=BaseOS&infra=$infra
      #baseurl=http://mirror.centos.org/$contentdir/$releasever/BaseOS/$basearch/os/
      baseurl=https://vault.centos.org/centos/$releasever/BaseOS/$basearch/os/
      gpgcheck=1
      enabled=1
      gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial
      ```
   3. CentOS-Linux-AppStream.repo的内容修改为：
      ```
      [appstream]
      name=CentOS Linux $releasever - AppStream
      #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=AppStream&infra=$infra
      #baseurl=http://mirror.centos.org/$contentdir/$releasever/AppStream/$basearch/os/
      baseurl=https://vault.centos.org/centos/$releasever/AppStream/$basearch/os/
      gpgcheck=1
      enabled=1
      gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial
      ```
2. Windows10远程桌面连接CentOS8
   1. 安装epel库
      1. 先查看下虚拟机上是否安装epel库
         ```
         rpm -qa|grep epel
         ```
      2. 如果没有安装，使用下面的命令进行安装
         ```
         yum install epel-release
         ```
   2. 安装xrdp
      ```
      yum install xrdp 
      ```
   3. 安装tigervnc-server
      ```
      yum install tigervnc-server
      ```
   4. 配置或关闭SELinux
      ```
      /usr/sbin/sestatus -v 
      ```
      ```
      setenforce 0 
      ```
   5. 关闭防火墙
      1. systemctl disable firewalld 禁止开机启用防火墙
      2. systemctl stop firewalld 停止防火墙服务   
   6. 启动xrdp服务，并且设置为开机启动
      ```
      systemctl start xrdp
      ```
      ```
      systemctl status xrdp
      ```
      ```
      systemctl enable xrdp
      ```
   7. 使用win10连接
3. tigervnc
   Installing a graphical desktop environment
   At this stage, it is assumed to work under the root user.
   By default, CentOS 8 does not have a graphical user interface, and it is required to connect to the server via VNC. So let's install Gnome.

   dnf groupinstall "Server with GUI"

   Installing TigerVNC
   Now let's install the TigerVNC server.

   dnf install tigervnc-server

   To connect to the server via VNC, it is better not to use the root user, because it is not safe. In addition, some functions may not work correctly. Therefore, we will create a regular user for connection, set a password for it and add it to the wheel group. This will give him sudo authority.

   adduser username

   passwd username

   usermod -aG wheel username

   TigerVNC configuration
   Now we need to assign each user an individual port for connection. To do this, open the file:

   nano /etc/tigervnc/vncserver.users

   Add the following line to the end. You can put as many users with ports there as you need. The last digit of the port is shown here. The first part will always be 590x. In this case, we will set port 5902 for the user username. The port for each user must be unique.

   :2=username

   Now open the default config file.

   nano /etc/tigervnc/vncserver-config-defaults

   Add the default configuration here:

   session=gnome

   Now you need to log in with the newly created user.

   su - username

   Set a password for this TigerVNC server user. If you choose a view-only password, you won't be able to control your computer, only watch.

   vncpasswd

   Now start the TigerVNC service and add it to autostart.

   sudo systemctl enable --now vncserver@:2

   Remote Desktop Connection via VNC

### java学习
#### JDBC学习
1. 抽取JDBC的工具类
   1. 工具类来获取connect对象
2. preparedstatement对象
   1. sql注入问题
   2. 使用PreparedStatement对象来解决
      1. 预编译的sql，参数使用？作为占位符替代
      2. 步骤：
         1. 定义sql 的时候与之前的有区别
         2. select * from user where username = ? and password = ?;
         3. 执行sql语句的对象， connection.prepareStatement(String sql)
         4. 给？赋值
            1. setXX(参数1，参数2)
            ```
            conn = DriverManager.getConnection(url, username, password);
            String sql = "select * from account where id = ?";

            pstmt = conn.prepareStatement(sql);
            pstmt.setInt(1,2);
            rs = pstmt.executeQuery();
            rs.next();
            int id = rs.getInt(1);
            String name = rs.getString("name");
            double money = rs.getDouble(3);
            ```
         5. 执行
3. 事务操作
   ```
   //注册驱动
        //Class.forName("com.mysql.cj.jdbc.Driver");
        //获取链接
        String url = "jdbc:mysql://127.0.0.1:3306/db1?characterEncoding=UTF-8&serverTimezone=UTC";
        //下面这种也可以，只要是本机+默认端口号
        //String url = "jdbc:mysql:///db1?characterEncoding=UTF-8&serverTimezone=UTC";
        String username = "root";
        String password = "123456";
        Connection conn = DriverManager.getConnection(url,username,password);
        System.out.println("数据库连接成功");
        //定义sql
        String sql1 = "update account set money = 1000 where id = 5";
        String sql2 = "update account set money = 1000 where id = 2";
        //获取执行sql的对象 Statement
        Statement stmt = conn.createStatement();

        try {
            //开启事务
            conn.setAutoCommit(false);
            System.out.println("开启事务");
            //执行sql
            int count1 = stmt.executeUpdate(sql1);
            //int i = 3/0;
            int count2 = stmt.executeUpdate(sql2);
            //处理这个结果
            System.out.println(count1);
            System.out.println(count2);
            conn.commit();
            System.out.println("成功提交事务");
        } catch (Exception e) {
            //回滚事务
            conn.rollback();
            System.out.println("回滚事务");
            throw new RuntimeException(e);
        }


        //释放资源
        stmt.close();
        conn.close();
   ```
4. 数据库连接池
   1. 简介
      1. 搞了一个容器，在这个容器里面，申请了很多的连接对象。用户来访问数据库，用户不会向系统底层申请连接，而是从容器中申请连接对象。用户使用完，会把连接对象归还给容器。 
      2. 这个被称为容器的技术，也叫池子的技术。
      3. 节约资源，高效
      4. 连接池是sun公司定义好的规则
      5. DataSource 是一个接口，代表数据源，我们说成连接池。由驱动程序供应商实现。
      6. 基本实现，生成标准的Connection对象。
      7. 获取连接的方法 Connection（）
      8. 一般我们不去实现，由数据库厂商来实现
         1.  C3P0
         2.  Druid
      9.  标准接口
          1.  获取链接getConnection（） 
          2.  归还链接close（）
   2.  c3p0
       1.  导入jar包
       2.  这块跳过，后面遇到再看
5. springJDBC : JDBC Template
   1. 提供JDBCTemplate对象，来简化JDBC的开发
   2. 步骤
      1. 导入jar包
      2. 创建JDBCTemplate对象，依赖于数据源DataSource
      3. 使用方法，来完成crud的操作。
         1. update()执行DML语句
         2. query()
            1. queryForMap()
            2. queryForList()
            3. query()结果为JavaBean
            4. queryForObject()

## 2022-08-27
### java学习
#### JDBC学习
接着上次的学习，补学数据库连接池，并且下载资料
1. 数据库连接池实现技术学习
      1. C3P0
         1. 导入jar包两个，创建libs文件夹，add as library
         2. 
         3. 定义配置文件
            1. 文件名固定 c3po.properties或者c3po-config.xml
            2. DataSource ds = new ComboPooledDataSource();什么都不传，使用默认配置，也可以使用指定名称配置DataSource ds = new ComboPooledDataSource("otherc3p0");
            ```xml
            <c3p0-config>
            <!-- 使用默认的配置读取连接池对象 -->
            <default-config>
               <!--  连接参数 -->
               <property name="driverClass">com.mysql.cj.jdbc.Driver</property>
               <property name="jdbcUrl">jdbc:mysql://127.0.0.1:3306/db1?characterEncoding=UTF-8&serverTimezone=UTC</property>
               <property name="user">root</property>
               <property name="password">123456</property>
               
               <!-- 连接池参数 -->
               <property name="initialPoolSize">5</property>
               <property name="maxPoolSize">10</property>
               <property name="checkoutTimeout">3000</property>
            </default-config>

            <named-config name="otherc3p0"> 
               <!--  连接参数 -->
               <property name="driverClass">com.mysql.jdbc.Driver</property>
               <property name="jdbcUrl">jdbc:mysql://localhost:3306/day25</property>
               <property name="user">root</property>
               <property name="password">root</property>
               
               <!-- 连接池参数 -->
               <property name="initialPoolSize">5</property>
               <property name="maxPoolSize">8</property>
               <property name="checkoutTimeout">1000</property>
            </named-config>
            </c3p0-config>
            ```
            1. 路径是classpath，也就是src目录下
         4. 创建核心对象，数据库连接池对象 comboPooledDatasource
            ```java
            package cn.itcast.datasource.C3P0;


            import com.mchange.v2.c3p0.ComboPooledDataSource;

            import javax.sql.DataSource;
            import java.sql.Connection;
            import java.sql.SQLException;

            public class C3P0DEMO1 {
               public static void main(String[] args) throws SQLException {
                  //创建数据库连接池对象
                  DataSource ds = new ComboPooledDataSource();
                  //获取连接对象
                  Connection conn = ds.getConnection();

                  System.out.println(conn);


               }
            }

            ```
            ```java
            package cn.itcast.datasource.C3P0;

            import com.mchange.v2.c3p0.ComboPooledDataSource;

            import javax.sql.DataSource;
            import java.sql.Connection;
            import java.sql.SQLException;

            public class C3P0DEMO2 {
               public static void main(String[] args) throws SQLException {
                  //创建数据库连接池对象
                  DataSource ds = new ComboPooledDataSource();
                  //获取连接对象

                  for (int i = 1; i < 11; i++) {
                        Connection conn = ds.getConnection();
                        System.out.println(i+":"+conn);
                        if(i == 5){
                           conn.close();//不是释放资源，而是归还连接到连接池中
                        }
                  }

                  Connection conn = ds.getConnection();//会报错,因为只能获取10个
               }
            }

            ```
      2. Druid
         1. 导入jar包 druid-1.0.9.jar
         2. 定义配置文件
            1. properties类型
            2. 可以说任意名称
         3. 获取数据库连接池对象，通过工厂来获取 DruidDatasourceFactory
         ```java
         package cn.itcast.datasource.Druid;

         import com.alibaba.druid.pool.DruidDataSourceFactory;

         import javax.sql.DataSource;
         import java.io.InputStream;
         import java.sql.Connection;
         import java.util.Properties;

         public class DruidDEMO {
            public static void main(String[] args) throws Exception {

               //加载配置文件
               Properties pro = new Properties();
               InputStream is = DruidDEMO.class.getClassLoader().getResourceAsStream("druid.properties");
               pro.load(is);
               DataSource dataSource = DruidDataSourceFactory.createDataSource(pro);
               //获取链接
               Connection conn = dataSource.getConnection();
               System.out.println(conn);
            }
         }
                  
         ```
         4. 定义工具类
            1. 定义一个类JDBCUtils
            2. 提供静态代码块加载配置文件，初始化连接池对象
            3. 提供方法
               1. 获取连接方法：通过数据库连接池获取连接
               2. 释放资源
               3. 获取连接池的方法
            ```java
            package cn.itcast.utils;

            import com.alibaba.druid.pool.DruidDataSourceFactory;

            import javax.sql.DataSource;
            import java.io.IOException;
            import java.sql.Connection;
            import java.sql.ResultSet;
            import java.sql.SQLException;
            import java.sql.Statement;
            import java.util.Properties;

            public class JDBCUtils {

               //定义一个成员变量，DataSource
               private static DataSource ds;
               static {
                  //加载配置文件
                  Properties pro = new Properties();
                  //获取DataSource
                  try {
                        pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties"));
                        ds = DruidDataSourceFactory.createDataSource(pro);
                  } catch (IOException e) {
                        throw new RuntimeException(e);
                  } catch (Exception e) {
                        throw new RuntimeException(e);
                  }
               }
               public static Connection getConnection() throws SQLException {
                  return ds.getConnection();
               }

               public static void close(Statement stmt, Connection conn){
                  if(stmt != null){
                        try {
                           stmt.close();
                        } catch (SQLException e) {
                           throw new RuntimeException(e);
                        }
                  }
                  if(conn != null){
                        try {
                           conn.close();
                        } catch (SQLException e) {
                           throw new RuntimeException(e);
                        }
                  }
               }

               public static void close(Statement stmt, Connection conn, ResultSet rs){
                  if(rs != null){
                        try {
                           rs.close();
                        } catch (SQLException e) {
                           throw new RuntimeException(e);
                        }
                  }
                  close(stmt,conn);
               }
            }
                        
            ```
         5. 测试工具类
            ```java
            package cn.itcast.datasource.Druid;

            import cn.itcast.utils.JDBCUtils;

            import java.sql.Connection;
            import java.sql.PreparedStatement;
            import java.sql.SQLException;

            public class DruidDEMO2 {
               //使用工具类

               //完成添加操作，给account添加一条记录
               public static void main(String[] args) {
                  Connection conn = null;
                  PreparedStatement pstmt = null;
                  try {

                        conn = JDBCUtils.getConnection();
                        String sql = "insert into account values(null,?,?)";
                        //获取pstmt对象
                        pstmt= conn.prepareStatement(sql);
                        //给？赋值
                        pstmt.setString(1,"王五");
                        pstmt.setDouble(2,5000);
                        int count = pstmt.executeUpdate();
                        System.out.println(count);
                  } catch (SQLException e) {
                        throw new RuntimeException(e);
                  } finally {
                        JDBCUtils.close(pstmt,conn);
                  }

               }
            }
            
            ```
         6. 
2. Spring JDBC
   1. 导入jar包
   2. 创建jdbcTemplate对象。依赖于数据源Datasource
      1. dbcTemplate template = new JdbcTemplate(ds);
   3. 调用JdbcTemplate的方法来完成CRUD的操作
      1. update()执行DML语句。增、删、改语句
         ```java
         package cn.itcast.JDBCTemplate;

         import cn.itcast.utils.JDBCUtils;
         import org.springframework.jdbc.core.JdbcTemplate;

         public class JDBCTemplateDEMO1 {
            public static void main(String[] args) {
               //导入jar包
               //创建JDBCTemplate对象
               JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());
               //调用方法
               String sql = "update account set money =6000 where id = ?";
               int count = template.update(sql,4);
               System.out.println(count);
            }
         }
                  
         ```
      2. queryForMap():查询结果将结果集封装为map集合
      3. queryForList():查询结果将结果集封装为li北t集合
      4. query():查询结果，将结果封装为]avaBean对象
      5. queryForobject:直询结果，俘结果封装为对象
   4. 练习
      ```java
      package cn.itcast.JDBCTemplate;

      import cn.itcast.domain.Emp;
      import cn.itcast.utils.JDBCUtils;
      import org.junit.Test;
      import org.springframework.jdbc.core.BeanPropertyRowMapper;
      import org.springframework.jdbc.core.JdbcTemplate;
      import org.springframework.jdbc.core.RowMapper;

      import java.sql.ResultSet;
      import java.sql.SQLException;
      import java.util.Date;
      import java.util.List;
      import java.util.Map;

      public class JDBCTemplateDEMO2 {
         private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());
         //Junit单元测试，可以让方法独立执行

         @Test
         public void test1(){
            String sql = "update emp set salary = 10000 where id = 3";
            int count = template.update(sql);
            System.out.println(count);
         }

         @Test
         public void test2(){
            String sql = "insert into emp(id,joindate,ename,salary) values(?,?,?,?)";
            int count = template.update(sql,27,"2020-03-11","maimai",10034);
            System.out.println(count);
         }

         @Test
         public void test3(){
            String sql = "delete from emp where id = ?";
            int count = template.update(sql,25);
            System.out.println(count);
         }

         @Test
         public void test4(){
            String sql = "select * from emp where id = ?";
            Map<String, Object> stringObjectMap = template.queryForMap(sql, 19);
            System.out.println(stringObjectMap);
         }

         @Test
         public void test5(){//此测试不能通过，因为queryForMap的查询结果数量只能为1
            String sql = "select * from emp where id = ? or id = ?";
            Map<String, Object> stringObjectMap = template.queryForMap(sql, 19,18);
            System.out.println(stringObjectMap);
         }

         @Test
         public void test6(){
            String sql = "select * from emp";
            List<Map<String, Object>> maps = template.queryForList(sql);
            System.out.println(maps.size());
         }

         @Test
         public void test7(){
            String sql = "select * from emp";
            List<Emp> query = template.query(sql, new RowMapper<Emp>() {
                  @Override
                  public Emp mapRow(ResultSet resultSet, int i) throws SQLException {
                     Emp emp = new Emp();
                     int id = resultSet.getInt("id");
                     String ename = resultSet.getString("ename");
                     Date joindate = resultSet.getDate("joindate");
                     double salary = resultSet.getDouble("salary");
                     double bonus = resultSet.getDouble("bonus");
                     int dep_id = resultSet.getInt("dep_id");
                     emp.setId(id);
                     emp.setEname(ename);
                     emp.setJoindate(joindate);
                     emp.setSalary(salary);
                     emp.setBonus(bonus);
                     emp.setDep_id(dep_id);
                     return emp;
                  }
            });

            for (Emp emp:
                  query) {
                  System.out.println(emp);
            }

         }

         @Test
         public void test8(){
            String sql = "select * from emp";
            List<Emp> query = template.query(sql, new BeanPropertyRowMapper<Emp>(Emp.class));
            for (Emp emp:
                     query) {
                  System.out.println(emp);
            }
         }

         @Test
         public void test9(){
            String sql = "select count(id) from emp";
            Long total = template.queryForObject(sql, Long.class);
            System.out.println(total);
         }      
      ```


### web学习

资源分类：
1. 静态资源
   1. 文本，图片，音频，视频，HTML，CSS，JavaScript
   2. 所有用户访问，得到的结果都是一样的
   3. 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源
2. 动态资源
   1. 使用动态网页技术发布的资源
   2. 所有用户访问，得到的结果可能不一样
   3. jsp/servlet，php，asp
   4. 如果用户请求的是动态资源，那么服务器回去执行这些动态资源，转换为静态资源，再发送给浏览器。因为浏览器只能够去执行这些静态资源。

#### HTML学习超文本标记语言
1. 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.
2. 标记语言，不是编程语言，只要写上就会执行，没有逻辑。
3. 标签学习
   1. 文件标签：构成html最基本的标签
      1. html
         1. html文档的根标签，所有的标签都是他的儿子
      2. head
         1. 头标签，用于指定html文档的一些属性。引入一些外部资源。
      3. title
         1. 定义标题的标签。
      4. body
         1. 体标签，
      5. <! DOCTYPE html>
         1. html5中定义该文档是html文档
      ```html
      <!DOCTYPE html>
      <html lang="en">
      <head>
         <meta charset="UTF-8">
         <title>呵呵</title>
      </head>
      <body>

      </body>
      </html>      
      ```
   2. 文本标签
   3. 图片标签
      ```html
      <!DOCTYPE html>
      <html lang="en">
      <head>
         <meta charset="UTF-8">
         <title>呵呵</title>
      </head>
      <body>
         <img src="./image/ji.png">
      </body>
      </html>      
      ```
   4. 列表标签
      ```html
      <!DOCTYPE html>
      <html lang="en">
      <head>
         <meta charset="UTF-8">
         <title>Title</title>
      </head>
      <body>
      <ol type="I">
         <li>法师</li>
         <li>秘术</li>
         <li>格斗</li>
         <li>换形</li>
      </ol>
      <ul type="I">
            <li>法师</li>
            <li>秘术</li>
            <li>格斗</li>
            <li>换形</li>
      </ul>
      </body>
      </html>      
      ```
   5. 链接标签
      ```html
      <!DOCTYPE html>
      <html lang="en">
      <head>
         <meta charset="UTF-8">
         <title>超链接</title>
      </head>
      <body>
      <a href="https://www.baidu.com"> 点我</a>

      <a href="https://www.baidu.com" target="_self"> 点我</a>
      <a href="https://www.baidu.com" target="_blank"> 点我</a>
      </body>
      </html>      
      ```
   6. <div>,<span>
      1. span本身没有任何样式，所以css在此基础上可以添加各种样式，默认在一行展示。称为行内标签，内联标签
      2. div通span，但是会换行，称为块级标签
   7. 语义化标签
      1. html5，取代id的一种策略
      2. fotter和div是一样的，没有任何样式。
      3. 便于阅读，提高程序的可读性
   8. 表格标签
      1. thead,tbody,tfoot,没有任何的样式改变
         ```html
         <!DOCTYPE html>
         <html lang="en">
         <head>
            <meta charset="UTF-8">
            <title>Title</title>
         </head>
         <body>
         <table border="1" width="50%" >
               <thead>
               <caption>学生信息表</caption>

               <tr>
                  <th>编号</th>
                  <th>姓名</th>
                  <th>成绩</th>
               </tr>
               </thead>
               <tbody>
               <tr>
                  <td>1</td>
                  <td>茗轩神</td>
                  <td>100</td>
               </tr>
               <tr>
                  <td>2</td>
                  <td>小茄子</td>
                  <td>100</td>
               </tr>

               </tbody>
               <tfoot>
               <tr>
                  <td>3</td>
                  <td>陆宇琪</td>
                  <td>100</td>
               </tr>
               </tfoot>

         </table>
         </body>
         </html>
         ```
      2. 合并行，合并列
         ```html
         <!DOCTYPE html>
         <html lang="en">
         <head>
            <meta charset="UTF-8">
            <title>Title</title>
         </head>
         <body>
         <table border="1" width="50%" >

         <caption>学生信息表</caption>

         <tr>
            <th rowspan="2">编号</th>
            <th>姓名</th>
            <th>成绩</th>
         </tr>


         <tr>
            <td>1</td>
            <td>茗轩神</td>
            <td>100</td>
         </tr>
         <tr>
            <td>2</td>
            <td>小茄子</td>
            <td>100</td>
         </tr>



         <tr>
            <td>3</td>
            <td colspan="2">陆宇琪</td>
            <td>100</td>
         </tr>


         </table>
         </body>
         </html>         
         ```
   9. 表单标签
      1. 用于采集用户输入的数据。用于和服务器进行交互
      2. form
      3. 表单仅仅定义了一个范围
      4. 属性
         1. action：指定提交数据的url
         2. method：指定提交方式
      5. 表单中的数据想要被提交，必须指定其name属性
      6. get请求参数会在地址栏中显示，请求参数的长度是有限制的
      7. post请求参数不会再地址栏中显示，请求参数的大小没有限制
      8. 表单项标签
         1. input type属性
            1. text
            2. password
            3. radio单选
            4. checkbox 复选
            5. file
            6. hidden
            7. color
            8. date
            9. datetime-local
            10. email
            11. number
            12. province
            13. submit
            14. button
            15. image
         2.  textarea
         ```html
         <!DOCTYPE html>
         <html lang="en">
         <head>
            <meta charset="UTF-8">
            <title>form</title>
         </head>
         <body>
            <form action="#" method="get">
               用户名：<input name="name"><br>
               密码：<input name="password"><br>
               <input type="submit" value="登录">

            </form>
            <form action="#" method="get">

               <label for="username"> 用户名 </label>：<input type="text" name="username" placeholder="请输入用户名" id="username"><br>
               密码：<input type="password" name="password" placeholder="请输入密码"><br>
               性别：<input type="radio" name="gender" value="male" >  男
               <input type="radio" name="gender" value="female" checked>  女
               <br>
               爱好：<input type="checkbox" name="hobby" value="shopping"> 逛街
               <input type="checkbox" name="hobby" value="java"  checked> Java
               <input type="checkbox" name="hobby" value="game"> 游戏<br>

               图片：<input type="file" name="file"><br>
               隐藏域：<input type="hidden" name="id" value="aaa"> <br>

               取色器：<input type="color" name="color"><br>
               生日：<input type="date" name="birthday"> <br>
               生日：<input type="datetime-local" name="birthday"> <br>
               邮箱：<input type="email" name="email"> <br>
               年龄：<input type="number" name="age"> <br>

               省份：<select name="province">
               <option value="">--请选择--</option>
               <option value="1">北京</option>
               <option value="2">上海</option>
               <option value="3" selected>陕西</option>
            </select><br>

               自我描述：
               <textarea cols="20" rows="5" name="des"></textarea>

               <br>
               <input type="submit" value="登录" >
               <input type="button" value="一个按钮" ><br>
               <input type="image" src="img/regbtn.jpg">


            </form>

         </body>
         </html>
         ```
## 2022-08-28
### 组会王琴琴师姐分享
![](https://tallestdaisy.oss-cn-beijing.aliyuncs.com/img/20220828103725.png)
1. 图匹配，很慢
2. 现在都用图神经网络来做
3. Gemini的问题，有语义丢失的问题，把基本快变成了向量。没有考虑序列特征。
4. ![](https://tallestdaisy.oss-cn-beijing.aliyuncs.com/img/20220828104052.png)
5. 邻接矩阵可以看出来相似性，基本快都为5，连接关系也有相似。
6. ![](https://tallestdaisy.oss-cn-beijing.aliyuncs.com/img/20220828104235.png)
7. ![](https://tallestdaisy.oss-cn-beijing.aliyuncs.com/img/20220828104636.png)
8. ![](https://tallestdaisy.oss-cn-beijing.aliyuncs.com/img/20220828104721.png)
9. 语义感知模块得到的embedding去结构模块
10. ![](https://tallestdaisy.oss-cn-beijing.aliyuncs.com/img/20220828105120.png)

恶意代码，给所有的代码，给出关联分析，判断好的坏的

### java学习
#### css学习
页面美化工作，页面布局控制
1. 概念：cascading style sheets
2. 层叠:多个样式可以作用在同一个html的元素上，同时生效
3. 好处
   1. 功能强大
   2. 将内容的展示和样式控制分离。也就是不用在标签里面写样式了
   3. 降低耦合度
4. 使用
   1. 内联样式
      1. 在标签内使用style属性指定css代码
      2. 不推荐使用
   2. 内部样式
      1. 在head定义style标签定义样式
### 论文复现 
无